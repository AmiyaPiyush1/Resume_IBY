
## LLM Interaction Logs
Note: This is a curated summary of key interactions with a Large Language Model (LLM) during the development of the AI Resume Agent. It highlights the prompts used to scaffold the architecture, develop core components, integrate features, and refactor the code for professional quality.

### Session 1: Backend Architecture and Agent Logic
My Goal: To create the initial Node.js server and define the multi-agent workflow for processing the resume.

My Prompt:

I'm building an AI agent prototype with Node.js and Express. The main task is to tailor a resume to a job description. I envision a multi-agent system: 1. Extractor Agent, 2. Planner Agent, and 3. Executor Agent. Can you generate a basic Express server setup with a single POST endpoint /api/process that outlines this flow? Also, set up the Google Generative AI client.

<br>

AI Response:

[The AI provided the initial server.js boilerplate, including the Express setup, a /api/process route handler, and placeholder functions like runExtractorAgent(), runPlannerAgent(), and runExecutorAgent(). It also included the initial setup for the @google/generative-ai package.]

<br>

My Prompt:

This is a great start. Now, let's write the prompt for the Extractor Agent. It needs to be very specific about the output JSON schema. The schema should include keys like name, email, summary, skills (as an array), experience (as an array of objects), and education. Please create a prompt template for this.

<br>

AI Response:

[The AI generated the extractorPromptTemplate string with a detailed description of its task and the exact JSON schema required, including placeholders for the raw resume text. This became the basis for the final prompt in the source code.]

### Session 2: Frontend UI and Interactive Components
My Goal: To build the user interface in React and create a key interactive feature for editing the final result.

My Prompt:

I'm creating the frontend for my AI agent in React using Vite and Tailwind CSS. I need a two-column layout. The left column will have text areas for the user's resume and a job description. The right column will display the AI-generated result. Can you scaffold a basic App.jsx component with this structure?

<br>

AI Response:

[The AI provided the JSX for a two-column layout using Flexbox in Tailwind CSS, with textarea elements on the left and a placeholder div on the right. It also set up the basic useState hooks for managing the inputs.]

<br>

My Prompt:

I want the results in the right column to be editable. I need a React component called EditableField. It should display text normally. When a user clicks the text, it should transform into a text input or textarea. When the input loses focus (onBlur), it should call a save function with the new value. Can you write this component?

<br>

AI Response:

[The AI generated the complete EditableField component, including the state management for isEditing and the logic to switch between a div and an input/textarea, which was then integrated directly into the project.]

### Session 3: Integrating External Tools
My Goal: To add more value to the user by integrating an external API to suggest jobs based on the newly tailored resume.

My Prompt:

I want to add a "suggested jobs" feature. After the resume is tailored, I'll use its new title and skills to search for jobs. I've found the "JSearch" API on RapidAPI. Can you show me how to write an async function in my Node.js backend to call this API using axios? It should take a search query and page number as arguments.

<br>

AI Response:

[The AI provided the fetchJobs async function, including the axios request configuration with the correct URL, params, and headers required for the RapidAPI service. It also included error handling.]

### Session 4: Robustness and Error Handling
My Goal: To make the communication with the LLM more reliable.

My Prompt:

My application sometimes fails when parsing the response from the Gemini API because the JSON is occasionally wrapped in markdown code fences (```json ... ```). What is a robust way to clean this string before passing it to JSON.parse() to prevent crashes?

<br>

AI Response:

[The AI suggested using a string replacement method (.replace(/```json/g, '').replace(/```/g, '')) to strip the markdown fences and recommended wrapping the JSON.parse() call in a try...catch block for graceful error handling. This logic was implemented in the runAgent function.]

### Session 5: Final Professional Refactoring
My Goal: To clean up the code, improve structure, and ensure it meets professional standards before submission.

My Prompt:

My prototype is functionally complete, but I want to refactor the code to be more structured and professional.

Specifically, in my server.js, the main /api/process endpoint feels monolithic and has too much logic. Could you suggest a way to break it down into smaller, reusable helper functions?

Also, in my React App.jsx, the main component is getting cluttered with default text and state declarations. What's a good way to clean this up?

<br>

AI Response:

That's an excellent step. Refactoring for clarity is a key professional skill. Here are my suggestions:

For your server.js backend:

Create Helper Functions: Abstract the core logic into dedicated async functions. This follows the Single Responsibility Principle.

Create a runAgent(prompt) function to handle the logic of calling the Gemini API and parsing the response.

Keep the fetchJobs(query, page) function you created earlier.

Simplify the Main Route: Your /api/process route should now just orchestrate calls to these helper functions. It will be much cleaner and read like a sequence of steps:

JavaScript

// Simplified route
app.post('/api/process', async (req, res) => {
  // 1. Get user input
  // 2. Call runAgent for Extractor
  const resumeJSON = await runAgent(extractorPrompt);
  // 3. Call runAgent for Planner
  const plan = await runAgent(plannerPrompt);
  // 4. Call runAgent for Executor
  const newSections = await runAgent(executorPrompt);
  // 5. Assemble the final resume
  // 6. Call fetchJobs for job suggestions
  // 7. Send the combined response
});
For your App.jsx frontend:

Use Constants for Default Data: Move the large default resume and job description strings out of the component's body and into a defaultText constant object at the top of the file. This makes your component's state initialization much cleaner.

JavaScript

const defaultText = {
  resume: `John Doe...`,
  jobDesc: `We are looking for...`
};
export default function App() {
  const [resumeText, setResumeText] = useState(defaultText.resume);
  // ...
}
```
Use Concise Variable Names: To improve readability, consider shortening long variable names where the context is clear (e.g., jobDescription to jobDesc, tailoredResume to result). This can make the code quicker to scan.

This refactoring will make your code significantly more readable, maintainable, and professional.






